# Руководство для разработчиков Orbita OS

## Важно для AI-агентов

**ОБЯЗАТЕЛЬНО ПРОЧИТАЙТЕ ФАЙЛ [PIPELINE.md](PIPELINE.md)!**

В нем описан подробный процесс разработки, включая:
- Пошаговую проверку кода
- Типичные ошибки Rust и их исправление
- Процесс самопроверки для агентов, которые не могут запускать код
- Порядок разработки модулей

## Структура проекта

```
orbita/
├── src/                    # Исходный код ядра
│   ├── main.rs            # Точка входа
│   ├── kernel.rs          # Основная логика ядра
│   ├── memory.rs          # Управление памятью
│   ├── allocator.rs       # Аллокатор кучи
│   ├── interrupts.rs      # Обработчики прерываний
│   ├── gdt.rs             # Global Descriptor Table
│   ├── graphics.rs        # Графическая подсистема
│   ├── serial.rs          # Последовательный порт для отладки
│   └── vga_buffer.rs      # VGA текстовый буфер
├── bootloader/             # Загрузчик
├── drivers/                # Драйверы устройств
├── docker/                 # Docker конфигурация
├── docs/                   # Документация
│   └── changelog/         # История изменений
├── scripts/                # Вспомогательные скрипты
├── Cargo.toml             # Конфигурация проекта
└── linker.ld              # Скрипт компоновщика
```

## Правила разработки

### 1. Используемые библиотеки

**ВАЖНО**: Используются только следующие no-std библиотеки из Cargo.toml:
- `bootloader` - загрузчик
- `volatile` - работа с волатильной памятью
- `spin` - спин-блокировки
- `x86_64` - архитектурно-зависимые функции
- `uart_16550` - последовательный порт
- `pic8259` - контроллер прерываний
- `pc-keyboard` - обработка клавиатуры
- `linked_list_allocator` - аллокатор памяти
- `lazy_static` - статические переменные
- `raw-cpuid` - информация о CPU
- `bit_field` - работа с битовыми полями
- `bitflags` - битовые флаги
- `log` - логирование
- `font8x8` - шрифты для графики
- `vek` - векторная математика
- `libm` - математические функции
- `num-traits` - числовые трейты
- `heapless` - структуры данных без аллокации
- `nb` - non-blocking I/O трейты
- `embedded-graphics` - графические примитивы
- `tinybmp` - работа с BMP изображениями

**ВСЕ ОСТАЛЬНОЕ ПИШЕТСЯ С НУЛЯ НА ЧИСТОМ RUST!**

### 2. Стиль кода

- Используйте rustfmt для форматирования
- Следуйте Rust naming conventions
- Документируйте публичные API
- Пишите тесты для критических компонентов

### 3. Разработка драйверов

Все драйверы создаются с нуля по следующей структуре:

```rust
// drivers/sound/ac97.rs
#![no_std]

use core::ptr;
use x86_64::instructions::port::Port;

pub struct AC97Driver {
    base_port: u16,
    // ... другие поля
}

impl AC97Driver {
    pub fn new(base_port: u16) -> Self {
        Self { base_port }
    }

    pub fn init(&mut self) {
        // Инициализация драйвера
        unsafe {
            let mut port = Port::new(self.base_port);
            // ... конфигурация
        }
    }

    pub fn play_sound(&mut self, data: &[u8]) {
        // Воспроизведение звука
    }
}
```

### 4. Процесс разработки для AI-агентов

**КРИТИЧЕСКИ ВАЖНО**: Перед написанием любого кода прочитайте [PIPELINE.md](PIPELINE.md)!

Основные принципы:
1. Всегда проверяйте код мысленно, так как вы не можете его запустить
2. Особое внимание уделяйте правилам borrowing в Rust
3. Проверяйте все импорты и зависимости
4. Документируйте каждый unsafe блок

### 5. Документация изменений

Для каждого изменения создавайте файл в `docs/changelog/`:

```markdown
# YYYY-MM-DD_module_name.md

## Изменения
- Добавлена поддержка ...
- Исправлен баг в ...
- Рефакторинг модуля ...

## Технические детали
Подробное описание изменений...

## Тестирование
Описание проведенных тестов...
```

### 6. Параллельная разработка

Для работы в команде:

1. Каждый разработчик работает в своей ветке
2. Именование веток: `feature/module-name` или `fix/bug-description`
3. Перед merge делайте code review
4. Используйте CI/CD для автоматических тестов

### 7. Сборка и запуск

```bash
# Сборка
cargo build --release

# Запуск в QEMU
cargo run

# Запуск с Docker
docker-compose up -d
docker exec -it orbita-dev bash
cargo run
```

### 8. Тестирование

```bash
# Запуск всех тестов
cargo test

# Запуск конкретного теста
cargo test module_name
```

### 9. Отладка

- Используйте `serial_println!` для вывода отладочной информации
- GDB можно подключить к QEMU: `qemu-system-x86_64 -s -S ...`
- Используйте `objdump` для анализа бинарного кода

## Архитектурные принципы

1. **Модульность**: Каждый компонент в отдельном модуле
2. **Безопасность**: Минимизация `unsafe` кода
3. **Эффективность**: Оптимизация критических путей
4. **Простота**: Понятный и читаемый код

## Этапы разработки

См. файлы:
- [TODO.md](TODO.md) - подробный план разработки
- [PIPELINE.md](PIPELINE.md) - процесс разработки и проверки кода