# Процесс разработки Orbita OS (Pipeline)

## Руководство для AI-агентов

Это руководство предназначено для AI-агентов, которые будут разрабатывать Orbita OS. Поскольку агенты не могут запускать код в своей среде, крайне важно следовать этому процессу для написания корректного кода.

## 1. Процесс написания кода

### Шаг 1: Анализ задачи
1. Внимательно прочитайте задачу из TODO.md
2. Определите, какие модули затрагивает задача
3. Изучите существующий код связанных модулей
4. Определите зависимости

### Шаг 2: Планирование
1. Разбейте задачу на мелкие подзадачи
2. Определите порядок реализации
3. Составьте список необходимых структур и функций

### Шаг 3: Написание кода
1. Начните с заголовков функций и структур
2. Реализуйте функциональность пошагово
3. Добавляйте документацию к каждой публичной функции

### Шаг 4: Самопроверка (КРИТИЧЕСКИ ВАЖНО!)

#### Проверка зависимостей
```rust
// Проверьте, что все используемые модули импортированы
use core::mem;
use alloc::vec::Vec;
use x86_64::VirtAddr;
```

#### Проверка синтаксиса Rust
1. **Borrowing правила**:
   ```rust
   // НЕПРАВИЛЬНО:
   let mut data = vec![1, 2, 3];
   let ref1 = &data;
   data.push(4); // Ошибка! Нельзя изменять при наличии заимствования
   
   // ПРАВИЛЬНО:
   let mut data = vec![1, 2, 3];
   {
       let ref1 = &data;
       // используем ref1
   } // ref1 выходит из области видимости
   data.push(4); // Теперь можно изменять
   ```

2. **Mutable/Immutable**:
   ```rust
   // НЕПРАВИЛЬНО:
   let data = vec![1, 2, 3];
   data.push(4); // Ошибка! data неизменяемый
   
   // ПРАВИЛЬНО:
   let mut data = vec![1, 2, 3];
   data.push(4);
   ```

3. **Lifetime annotations**:
   ```rust
   // Проверьте правильность времени жизни
   fn process<'a>(data: &'a [u8]) -> &'a [u8] {
       &data[1..]
   }
   ```

4. **Unsafe блоки**:
   ```rust
   // Убедитесь, что unsafe используется правильно
   unsafe {
       // Комментарий объясняющий почему это безопасно
       ptr::write_volatile(0xb8000 as *mut u8, b'H');
   }
   ```

### Шаг 5: Проверка no_std совместимости
1. Не используйте std библиотеку
2. Используйте core:: и alloc:: вместо std::
3. Проверьте, что все трейты из core

### Шаг 6: Проверка архитектурной совместимости
1. Убедитесь, что код работает на x86_64
2. Проверьте выравнивание структур
3. Убедитесь в правильном использовании портов ввода-вывода

## 2. Чек-лист перед коммитом

- [ ] Код компилируется без warnings
- [ ] Все публичные функции документированы
- [ ] Добавлены тесты для новой функциональности
- [ ] Проверен стиль кода (rustfmt)
- [ ] Нет неиспользуемых импортов
- [ ] Все unsafe блоки прокомментированы
- [ ] Создан файл в docs/changelog/
- [ ] Обновлен TODO.md (отмечены выполненные задачи)

## 3. Порядок разработки модулей

### Фаза 1: Базовое ядро (уже выполнено)
- [x] Загрузчик
- [x] GDT/IDT
- [x] Прерывания
- [x] Управление памятью
- [x] Аллокатор

### Фаза 2: Базовые драйверы
1. **PCI шина** (ПЕРВЫЙ ПРИОРИТЕТ)
   - Сканирование устройств
   - Чтение конфигурации
   - Управление ресурсами

2. **Таймер (PIT/APIC)**
   - Системное время
   - Планировщик задач
   - Задержки

3. **PS/2 контроллер**
   - Мышь
   - Расширенная клавиатура

### Фаза 3: Хранилище данных
1. **ATA/ATAPI драйвер**
   - PIO режим
   - DMA режим
   - ATAPI команды

2. **Файловая система (FAT32)**
   - Чтение загрузочного сектора
   - Навигация по директориям
   - Чтение файлов

### Фаза 4: Расширенная графика
1. **VESA/VBE драйвер**
   - Переключение режимов
   - Двойная буферизация
   - Аппаратное ускорение

2. **Оконный менеджер**
   - Отрисовка окон
   - Обработка событий
   - Композитинг

### Фаза 5: Звуковая подсистема
1. **AC97/HDA драйвер**
   - Инициализация кодека
   - DMA буферы
   - Микшер

2. **Звуковой API**
   - Воспроизведение WAV
   - Потоковое аудио

### Фаза 6: Сетевая подсистема
1. **Ethernet драйвер (RTL8139)**
   - Инициализация
   - Отправка/прием пакетов
   - Обработка прерываний

2. **TCP/IP стек**
   - Ethernet фреймы
   - IP пакеты
   - TCP соединения

### Фаза 7: Многозадачность
1. **Планировщик**
   - Переключение контекста
   - Приоритеты процессов
   - Квантование времени

2. **IPC (межпроцессное взаимодействие)**
   - Разделяемая память
   - Сообщения
   - Сигналы

## 4. Шаблон проверки кода

Перед отправкой кода, ответьте на эти вопросы:

1. **Компилируется ли код?**
   - Все ли импорты на месте?
   - Правильные ли типы используются?
   - Соблюдены ли правила borrowing?

2. **Безопасен ли код?**
   - Обоснованы ли все unsafe блоки?
   - Проверены ли границы массивов?
   - Обработаны ли ошибки?

3. **Эффективен ли код?**
   - Нет ли лишних копирований?
   - Оптимальны ли алгоритмы?
   - Правильно ли используется память?

4. **Понятен ли код?**
   - Есть ли документация?
   - Понятны ли имена переменных?
   - Логична ли структура?

## 5. Типичные ошибки и их исправление

### Ошибка 1: Неправильное использование unsafe
```rust
// НЕПРАВИЛЬНО:
unsafe {
    *(0xb8000 as *mut u16) = 0x0741;
}

// ПРАВИЛЬНО:
unsafe {
    // Записываем символ 'A' с белым цветом в VGA буфер
    let vga_buffer = 0xb8000 as *mut u16;
    ptr::write_volatile(vga_buffer, 0x0741);
}
```

### Ошибка 2: Забытые проверки границ
```rust
// НЕПРАВИЛЬНО:
fn get_element(data: &[u8], index: usize) -> u8 {
    data[index]
}

// ПРАВИЛЬНО:
fn get_element(data: &[u8], index: usize) -> Option<u8> {
    data.get(index).copied()
}
```

### Ошибка 3: Неправильная обработка ошибок
```rust
// НЕПРАВИЛЬНО:
let value = some_function().unwrap();

// ПРАВИЛЬНО:
let value = some_function().map_err(|e| {
    serial_println!("Error: {:?}", e);
    e
})?;
```

## 6. Документирование изменений

Для каждого изменения создайте файл:
`docs/changelog/YYYY-MM-DD_module_description.md`

Шаблон:
```markdown
# YYYY-MM-DD Module Description

## Изменения
- Что добавлено
- Что изменено
- Что исправлено

## Технические детали
- Архитектурные решения
- Алгоритмы
- Оптимизации

## Тестирование
- Какие тесты написаны
- Что протестировано вручную
- Известные проблемы

## Следующие шаги
- Что нужно сделать дальше
- Зависимости для других модулей
```

## 7. Работа с Git (для человека-координатора)

1. Создайте ветку для каждой функции
2. Делайте атомарные коммиты
3. Пишите понятные сообщения коммитов
4. Используйте PR для code review

## 8. Вопросы для самопроверки

Перед завершением работы над модулем, спросите себя:

1. Может ли этот код вызвать панику ядра?
2. Правильно ли обрабатываются все ошибки?
3. Есть ли утечки памяти?
4. Корректно ли работает код в многопоточной среде?
5. Достаточно ли тестов?
6. Понятна ли документация?
7. Следует ли код архитектуре проекта?
8. Оптимален ли код по производительности?

## Помните!

- Вы не можете запустить код, поэтому проверяйте его мысленно
- Лучше написать меньше кода, но правильного
- Документация так же важна, как и код
- Безопасность превыше производительности
- Если сомневаетесь - спросите или перепроверьте